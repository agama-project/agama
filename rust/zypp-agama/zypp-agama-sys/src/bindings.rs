/* automatically generated by rust-bindgen 0.72.1 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProgressData {
    pub value: ::std::os::raw::c_longlong,
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ProgressData"][::std::mem::size_of::<ProgressData>() - 16usize];
    ["Alignment of ProgressData"][::std::mem::align_of::<ProgressData>() - 8usize];
    ["Offset of field: ProgressData::value"][::std::mem::offset_of!(ProgressData, value) - 0usize];
    ["Offset of field: ProgressData::name"][::std::mem::offset_of!(ProgressData, name) - 8usize];
};
#[doc = " @return true to continue, false to abort. Can be ignored"]
pub type ZyppProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(zypp_data: ProgressData, user_data: *mut ::std::os::raw::c_void) -> bool,
>;
pub const PROBLEM_RESPONSE_PROBLEM_RETRY: PROBLEM_RESPONSE = 0;
pub const PROBLEM_RESPONSE_PROBLEM_ABORT: PROBLEM_RESPONSE = 1;
pub const PROBLEM_RESPONSE_PROBLEM_IGNORE: PROBLEM_RESPONSE = 2;
pub type PROBLEM_RESPONSE = ::std::os::raw::c_uint;
pub const OPTIONAL_PROBLEM_RESPONSE_OPROBLEM_RETRY: OPTIONAL_PROBLEM_RESPONSE = 0;
pub const OPTIONAL_PROBLEM_RESPONSE_OPROBLEM_ABORT: OPTIONAL_PROBLEM_RESPONSE = 1;
pub const OPTIONAL_PROBLEM_RESPONSE_OPROBLEM_IGNORE: OPTIONAL_PROBLEM_RESPONSE = 2;
pub const OPTIONAL_PROBLEM_RESPONSE_OPROBLEM_NONE: OPTIONAL_PROBLEM_RESPONSE = 3;
pub type OPTIONAL_PROBLEM_RESPONSE = ::std::os::raw::c_uint;
pub const DownloadProgressError_DPE_NO_ERROR: DownloadProgressError = 0;
pub const DownloadProgressError_DPE_NOT_FOUND: DownloadProgressError = 1;
pub const DownloadProgressError_DPE_IO: DownloadProgressError = 2;
pub const DownloadProgressError_DPE_ACCESS_DENIED: DownloadProgressError = 3;
pub const DownloadProgressError_DPE_ERROR: DownloadProgressError = 4;
pub type DownloadProgressError = ::std::os::raw::c_uint;
pub type ZyppDownloadStartCallback = ::std::option::Option<
    unsafe extern "C" fn(
        url: *const ::std::os::raw::c_char,
        localfile: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
pub type ZyppDownloadProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        value: ::std::os::raw::c_int,
        url: *const ::std::os::raw::c_char,
        bps_avg: f64,
        bps_current: f64,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub type ZyppDownloadProblemCallback = ::std::option::Option<
    unsafe extern "C" fn(
        url: *const ::std::os::raw::c_char,
        error: DownloadProgressError,
        description: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> PROBLEM_RESPONSE,
>;
pub type ZyppDownloadFinishCallback = ::std::option::Option<
    unsafe extern "C" fn(
        url: *const ::std::os::raw::c_char,
        error: DownloadProgressError,
        reason: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DownloadProgressCallbacks {
    pub start: ZyppDownloadStartCallback,
    pub start_data: *mut ::std::os::raw::c_void,
    pub progress: ZyppDownloadProgressCallback,
    pub progress_data: *mut ::std::os::raw::c_void,
    pub problem: ZyppDownloadProblemCallback,
    pub problem_data: *mut ::std::os::raw::c_void,
    pub finish: ZyppDownloadFinishCallback,
    pub finish_data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DownloadProgressCallbacks"]
        [::std::mem::size_of::<DownloadProgressCallbacks>() - 64usize];
    ["Alignment of DownloadProgressCallbacks"]
        [::std::mem::align_of::<DownloadProgressCallbacks>() - 8usize];
    ["Offset of field: DownloadProgressCallbacks::start"]
        [::std::mem::offset_of!(DownloadProgressCallbacks, start) - 0usize];
    ["Offset of field: DownloadProgressCallbacks::start_data"]
        [::std::mem::offset_of!(DownloadProgressCallbacks, start_data) - 8usize];
    ["Offset of field: DownloadProgressCallbacks::progress"]
        [::std::mem::offset_of!(DownloadProgressCallbacks, progress) - 16usize];
    ["Offset of field: DownloadProgressCallbacks::progress_data"]
        [::std::mem::offset_of!(DownloadProgressCallbacks, progress_data) - 24usize];
    ["Offset of field: DownloadProgressCallbacks::problem"]
        [::std::mem::offset_of!(DownloadProgressCallbacks, problem) - 32usize];
    ["Offset of field: DownloadProgressCallbacks::problem_data"]
        [::std::mem::offset_of!(DownloadProgressCallbacks, problem_data) - 40usize];
    ["Offset of field: DownloadProgressCallbacks::finish"]
        [::std::mem::offset_of!(DownloadProgressCallbacks, finish) - 48usize];
    ["Offset of field: DownloadProgressCallbacks::finish_data"]
        [::std::mem::offset_of!(DownloadProgressCallbacks, finish_data) - 56usize];
};
pub const DownloadResolvableError_DRE_NO_ERROR: DownloadResolvableError = 0;
pub const DownloadResolvableError_DRE_NOT_FOUND: DownloadResolvableError = 1;
pub const DownloadResolvableError_DRE_IO: DownloadResolvableError = 2;
pub const DownloadResolvableError_DRE_INVALID: DownloadResolvableError = 3;
pub type DownloadResolvableError = ::std::os::raw::c_uint;
pub const DownloadResolvableFileError_DRFE_NO_ERROR: DownloadResolvableFileError = 0;
pub const DownloadResolvableFileError_DRFE_NOT_FOUND: DownloadResolvableFileError = 1;
pub const DownloadResolvableFileError_DRFE_IO: DownloadResolvableFileError = 2;
pub const DownloadResolvableFileError_DRFE_ACCESS_DENIED: DownloadResolvableFileError = 3;
pub const DownloadResolvableFileError_DRFE_ERROR: DownloadResolvableFileError = 4;
pub type DownloadResolvableFileError = ::std::os::raw::c_uint;
#[doc = "< Signature is OK."]
pub const GPGCheckPackageResult_CHK_OK: GPGCheckPackageResult = 0;
#[doc = "< Signature is unknown type."]
pub const GPGCheckPackageResult_CHK_NOTFOUND: GPGCheckPackageResult = 1;
#[doc = "< Signature does not verify."]
pub const GPGCheckPackageResult_CHK_FAIL: GPGCheckPackageResult = 2;
#[doc = "< Signature is OK, but key is not trusted."]
pub const GPGCheckPackageResult_CHK_NOTTRUSTED: GPGCheckPackageResult = 3;
#[doc = "< Public key is unavailable."]
pub const GPGCheckPackageResult_CHK_NOKEY: GPGCheckPackageResult = 4;
#[doc = "< File does not exist or can't be opened."]
pub const GPGCheckPackageResult_CHK_ERROR: GPGCheckPackageResult = 5;
#[doc = "< File has no gpg signature (only digests)."]
pub const GPGCheckPackageResult_CHK_NOSIG: GPGCheckPackageResult = 6;
pub type GPGCheckPackageResult = ::std::os::raw::c_uint;
pub type ZyppDownloadResolvableStartCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
pub type ZyppDownloadResolvableProblemCallback = ::std::option::Option<
    unsafe extern "C" fn(
        resolvable_name: *const ::std::os::raw::c_char,
        error: DownloadResolvableError,
        description: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> PROBLEM_RESPONSE,
>;
pub type ZyppDownloadResolvableGpgCheckCallback = ::std::option::Option<
    unsafe extern "C" fn(
        resolvable_name: *const ::std::os::raw::c_char,
        repo_url: *const ::std::os::raw::c_char,
        check_result: GPGCheckPackageResult,
        user_data: *mut ::std::os::raw::c_void,
    ) -> OPTIONAL_PROBLEM_RESPONSE,
>;
pub type ZyppDownloadResolvableFileFinishCallback = ::std::option::Option<
    unsafe extern "C" fn(
        url: *const ::std::os::raw::c_char,
        local_path: *const ::std::os::raw::c_char,
        error: DownloadResolvableFileError,
        error_details: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DownloadResolvableCallbacks {
    pub start_preload: ZyppDownloadResolvableStartCallback,
    pub start_preload_data: *mut ::std::os::raw::c_void,
    pub problem: ZyppDownloadResolvableProblemCallback,
    pub problem_data: *mut ::std::os::raw::c_void,
    pub gpg_check: ZyppDownloadResolvableGpgCheckCallback,
    pub gpg_check_data: *mut ::std::os::raw::c_void,
    pub file_finish: ZyppDownloadResolvableFileFinishCallback,
    pub file_finish_data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DownloadResolvableCallbacks"]
        [::std::mem::size_of::<DownloadResolvableCallbacks>() - 64usize];
    ["Alignment of DownloadResolvableCallbacks"]
        [::std::mem::align_of::<DownloadResolvableCallbacks>() - 8usize];
    ["Offset of field: DownloadResolvableCallbacks::start_preload"]
        [::std::mem::offset_of!(DownloadResolvableCallbacks, start_preload) - 0usize];
    ["Offset of field: DownloadResolvableCallbacks::start_preload_data"]
        [::std::mem::offset_of!(DownloadResolvableCallbacks, start_preload_data) - 8usize];
    ["Offset of field: DownloadResolvableCallbacks::problem"]
        [::std::mem::offset_of!(DownloadResolvableCallbacks, problem) - 16usize];
    ["Offset of field: DownloadResolvableCallbacks::problem_data"]
        [::std::mem::offset_of!(DownloadResolvableCallbacks, problem_data) - 24usize];
    ["Offset of field: DownloadResolvableCallbacks::gpg_check"]
        [::std::mem::offset_of!(DownloadResolvableCallbacks, gpg_check) - 32usize];
    ["Offset of field: DownloadResolvableCallbacks::gpg_check_data"]
        [::std::mem::offset_of!(DownloadResolvableCallbacks, gpg_check_data) - 40usize];
    ["Offset of field: DownloadResolvableCallbacks::file_finish"]
        [::std::mem::offset_of!(DownloadResolvableCallbacks, file_finish) - 48usize];
    ["Offset of field: DownloadResolvableCallbacks::file_finish_data"]
        [::std::mem::offset_of!(DownloadResolvableCallbacks, file_finish_data) - 56usize];
};
#[doc = " Reject the key."]
pub const GPGKeyTrust_GPGKT_REJECT: GPGKeyTrust = 0;
#[doc = " Trust key temporary. Will be asked again when something is signed with it.\nEven within same session."]
pub const GPGKeyTrust_GPGKT_TEMPORARY: GPGKeyTrust = 1;
#[doc = " Import key and trust it."]
pub const GPGKeyTrust_GPGKT_IMPORT: GPGKeyTrust = 2;
#[doc = " @brief What to do with an unknown GPG key.\n @see zypp::KeyRingReport::KeyTrust in\n https://github.com/openSUSE/libzypp/blob/master/zypp-logic/zypp/KeyRing.h"]
pub type GPGKeyTrust = ::std::os::raw::c_uint;
#[doc = " @brief Callback to decide whether to accept an unknown GPG key.\n @param key_id The ID of the GPG key.\n @param key_name The name of the GPG key.\n @param key_fingerprint The fingerprint of the GPG key.\n @param repository_alias The alias of the repository providing the key. Can be\n an empty string if not available.\n @param user_data User-defined data.\n @return A GPGKeyTrust value indicating the action to take.\n  @see zypp::KeyRingReport::askUserToAcceptKey in\n https://github.com/openSUSE/libzypp/blob/master/zypp-logic/zypp/KeyRing.h"]
pub type GPGAcceptKeyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        key_id: *const ::std::os::raw::c_char,
        key_name: *const ::std::os::raw::c_char,
        key_fingerprint: *const ::std::os::raw::c_char,
        repository_alias: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> GPGKeyTrust,
>;
#[doc = " @brief Callback for handling unsigned files.\n @param file The path to the unsigned file.\n @param repository_alias The alias of the repository. Can be an empty string\n if not available.\n @param user_data User-defined data.\n @return true to continue, false to abort."]
pub type GPGUnsignedFile = ::std::option::Option<
    unsafe extern "C" fn(
        file: *const ::std::os::raw::c_char,
        repository_alias: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " @brief Callback for handling a file signed by an unknown key.\n @param file The path to the file.\n @param key_id The ID of the unknown GPG key.\n @param repository_alias The alias of the repository. Can be an empty string\n if not available.\n @param user_data User-defined data.\n @return true to continue, false to abort."]
pub type GPGUnknownKey = ::std::option::Option<
    unsafe extern "C" fn(
        file: *const ::std::os::raw::c_char,
        key_id: *const ::std::os::raw::c_char,
        repository_alias: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " @brief Callback for when GPG verification of a signed file fails.\n @param file The path to the file.\n @param key_id The ID of the GPG key.\n @param key_name The name of the GPG key.\n @param key_fingerprint The fingerprint of the GPG key.\n @param repository_alias The alias of the repository. Can be an empty string\n if not available.\n @param user_data User-defined data.\n @return true to continue, false to abort."]
pub type GPGVerificationFailed = ::std::option::Option<
    unsafe extern "C" fn(
        file: *const ::std::os::raw::c_char,
        key_id: *const ::std::os::raw::c_char,
        key_name: *const ::std::os::raw::c_char,
        key_fingerprint: *const ::std::os::raw::c_char,
        repository_alias: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " @see zypp::DigestReport in\n https://github.com/openSUSE/libzypp/blob/master/zypp-logic/zypp/Digest.h"]
pub type ChecksumMissing = ::std::option::Option<
    unsafe extern "C" fn(
        file: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub type ChecksumWrong = ::std::option::Option<
    unsafe extern "C" fn(
        file: *const ::std::os::raw::c_char,
        expected: *const ::std::os::raw::c_char,
        actual: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub type ChecksumUnknown = ::std::option::Option<
    unsafe extern "C" fn(
        file: *const ::std::os::raw::c_char,
        checksum: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " @brief Callbacks for handling security related issues.\n\n This struct provides callbacks for handling various security-related events\n that can occur during libzypp operations, such as GPG key management and\n checksum verification.\n\n Each callback has a corresponding `_data` pointer that can be used to pass\n user-defined data to the callback function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SecurityCallbacks {
    #[doc = " @brief Callback to decide whether to accept an unknown GPG key."]
    pub accept_key: GPGAcceptKeyCallback,
    #[doc = " @brief User data for the `accept_key` callback."]
    pub accept_key_data: *mut ::std::os::raw::c_void,
    #[doc = " @brief Callback for handling unsigned files."]
    pub unsigned_file: GPGUnsignedFile,
    #[doc = " @brief User data for the `unsigned_file` callback."]
    pub unsigned_file_data: *mut ::std::os::raw::c_void,
    #[doc = " @brief Callback for handling files signed with an unknown key."]
    pub unknown_key: GPGUnknownKey,
    #[doc = " @brief User data for the `unknown_key` callback."]
    pub unknown_key_data: *mut ::std::os::raw::c_void,
    #[doc = " @brief Callback for handling GPG verification failures."]
    pub verification_failed: GPGVerificationFailed,
    #[doc = " @brief User data for the `verification_failed` callback."]
    pub verification_failed_data: *mut ::std::os::raw::c_void,
    #[doc = " @brief Callback for when a checksum is missing."]
    pub checksum_missing: ChecksumMissing,
    #[doc = " @brief User data for the `checksum_missing` callback."]
    pub checksum_missing_data: *mut ::std::os::raw::c_void,
    #[doc = " @brief Callback for when a checksum is wrong."]
    pub checksum_wrong: ChecksumWrong,
    #[doc = " @brief User data for the `checksum_wrong` callback."]
    pub checksum_wrong_data: *mut ::std::os::raw::c_void,
    #[doc = " @brief Callback for when the checksum type is unknown."]
    pub checksum_unknown: ChecksumUnknown,
    #[doc = " @brief User data for the `checksum_unknown` callback."]
    pub checksum_unknown_data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SecurityCallbacks"][::std::mem::size_of::<SecurityCallbacks>() - 112usize];
    ["Alignment of SecurityCallbacks"][::std::mem::align_of::<SecurityCallbacks>() - 8usize];
    ["Offset of field: SecurityCallbacks::accept_key"]
        [::std::mem::offset_of!(SecurityCallbacks, accept_key) - 0usize];
    ["Offset of field: SecurityCallbacks::accept_key_data"]
        [::std::mem::offset_of!(SecurityCallbacks, accept_key_data) - 8usize];
    ["Offset of field: SecurityCallbacks::unsigned_file"]
        [::std::mem::offset_of!(SecurityCallbacks, unsigned_file) - 16usize];
    ["Offset of field: SecurityCallbacks::unsigned_file_data"]
        [::std::mem::offset_of!(SecurityCallbacks, unsigned_file_data) - 24usize];
    ["Offset of field: SecurityCallbacks::unknown_key"]
        [::std::mem::offset_of!(SecurityCallbacks, unknown_key) - 32usize];
    ["Offset of field: SecurityCallbacks::unknown_key_data"]
        [::std::mem::offset_of!(SecurityCallbacks, unknown_key_data) - 40usize];
    ["Offset of field: SecurityCallbacks::verification_failed"]
        [::std::mem::offset_of!(SecurityCallbacks, verification_failed) - 48usize];
    ["Offset of field: SecurityCallbacks::verification_failed_data"]
        [::std::mem::offset_of!(SecurityCallbacks, verification_failed_data) - 56usize];
    ["Offset of field: SecurityCallbacks::checksum_missing"]
        [::std::mem::offset_of!(SecurityCallbacks, checksum_missing) - 64usize];
    ["Offset of field: SecurityCallbacks::checksum_missing_data"]
        [::std::mem::offset_of!(SecurityCallbacks, checksum_missing_data) - 72usize];
    ["Offset of field: SecurityCallbacks::checksum_wrong"]
        [::std::mem::offset_of!(SecurityCallbacks, checksum_wrong) - 80usize];
    ["Offset of field: SecurityCallbacks::checksum_wrong_data"]
        [::std::mem::offset_of!(SecurityCallbacks, checksum_wrong_data) - 88usize];
    ["Offset of field: SecurityCallbacks::checksum_unknown"]
        [::std::mem::offset_of!(SecurityCallbacks, checksum_unknown) - 96usize];
    ["Offset of field: SecurityCallbacks::checksum_unknown_data"]
        [::std::mem::offset_of!(SecurityCallbacks, checksum_unknown_data) - 104usize];
};
#[doc = " @brief No error occurred."]
pub const ZyppInstallPackageError_PI_NO_ERROR: ZyppInstallPackageError = 0;
#[doc = " @brief The requested URL was not found."]
pub const ZyppInstallPackageError_PI_NOT_FOUND: ZyppInstallPackageError = 1;
#[doc = " @brief An I/O error occurred."]
pub const ZyppInstallPackageError_PI_IO: ZyppInstallPackageError = 2;
#[doc = " @brief The resolvable is invalid."]
pub const ZyppInstallPackageError_PI_INVALID: ZyppInstallPackageError = 3;
#[doc = " @brief Errors that can occur during package installation.\n @see zypp::target::rpm::InstallResolvableReport::Error in libzypp."]
pub type ZyppInstallPackageError = ::std::os::raw::c_uint;
#[doc = " @brief Callback invoked when the installation of a package starts.\n @param package_name The name of the package being installed.\n @param user_data User-defined data."]
pub type ZyppInstallPackageStartCallback = ::std::option::Option<
    unsafe extern "C" fn(
        package_name: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Callback for handling problems during package installation.\n @param package_name The name of the package that has a problem.\n @param error The type of error that occurred.\n @param description A description of the problem.\n @param user_data User-defined data.\n @return A PROBLEM_RESPONSE value indicating how to proceed."]
pub type ZyppInstallPackageProblemCallback = ::std::option::Option<
    unsafe extern "C" fn(
        package_name: *const ::std::os::raw::c_char,
        error: ZyppInstallPackageError,
        description: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> PROBLEM_RESPONSE,
>;
#[doc = " @brief Callback invoked when the installation of a package finishes.\n @note We could add a finish message after package install, but YaST does not.\n Should we do it with Agama?\n @param user_data User-defined data."]
pub type ZyppInstallPackageFinishCallback = ::std::option::Option<
    unsafe extern "C" fn(
        package_name: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Callback for handling problems in package installation scripts (e.g.,\n post-install).\n @param description A description of the script problem.\n @param user_data User-defined data.\n @return A PROBLEM_RESPONSE value indicating how to proceed."]
pub type ZyppInstallScriptProblemCallback = ::std::option::Option<
    unsafe extern "C" fn(
        description: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> PROBLEM_RESPONSE,
>;
#[doc = " @brief Callbacks for monitoring the progress of package installation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InstallCallbacks {
    pub package_start: ZyppInstallPackageStartCallback,
    pub package_start_data: *mut ::std::os::raw::c_void,
    pub package_problem: ZyppInstallPackageProblemCallback,
    pub package_problem_data: *mut ::std::os::raw::c_void,
    pub script_problem: ZyppInstallScriptProblemCallback,
    pub script_problem_data: *mut ::std::os::raw::c_void,
    pub package_finish: ZyppInstallPackageFinishCallback,
    pub package_finish_data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of InstallCallbacks"][::std::mem::size_of::<InstallCallbacks>() - 64usize];
    ["Alignment of InstallCallbacks"][::std::mem::align_of::<InstallCallbacks>() - 8usize];
    ["Offset of field: InstallCallbacks::package_start"]
        [::std::mem::offset_of!(InstallCallbacks, package_start) - 0usize];
    ["Offset of field: InstallCallbacks::package_start_data"]
        [::std::mem::offset_of!(InstallCallbacks, package_start_data) - 8usize];
    ["Offset of field: InstallCallbacks::package_problem"]
        [::std::mem::offset_of!(InstallCallbacks, package_problem) - 16usize];
    ["Offset of field: InstallCallbacks::package_problem_data"]
        [::std::mem::offset_of!(InstallCallbacks, package_problem_data) - 24usize];
    ["Offset of field: InstallCallbacks::script_problem"]
        [::std::mem::offset_of!(InstallCallbacks, script_problem) - 32usize];
    ["Offset of field: InstallCallbacks::script_problem_data"]
        [::std::mem::offset_of!(InstallCallbacks, script_problem_data) - 40usize];
    ["Offset of field: InstallCallbacks::package_finish"]
        [::std::mem::offset_of!(InstallCallbacks, package_finish) - 48usize];
    ["Offset of field: InstallCallbacks::package_finish_data"]
        [::std::mem::offset_of!(InstallCallbacks, package_finish_data) - 56usize];
};
#[doc = " status struct to pass and obtain from calls that can fail.\n After usage free with \\ref free_status function.\n\n Most functions act as *constructors* for this, taking a pointer\n to it as an output parameter, disregarding the struct current contents\n and filling it in. Thus, if you reuse a `Status` without \\ref free_status\n in between, `error` will leak."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Status {
    pub state: Status_STATE,
    #[doc = "< owned"]
    pub error: *mut ::std::os::raw::c_char,
}
pub const Status_STATE_STATE_SUCCEED: Status_STATE = 0;
pub const Status_STATE_STATE_FAILED: Status_STATE = 1;
pub type Status_STATE = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Status"][::std::mem::size_of::<Status>() - 16usize];
    ["Alignment of Status"][::std::mem::align_of::<Status>() - 8usize];
    ["Offset of field: Status::state"][::std::mem::offset_of!(Status, state) - 0usize];
    ["Offset of field: Status::error"][::std::mem::offset_of!(Status, error) - 8usize];
};
#[doc = " Opaque Zypp context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Zypp {
    _unused: [u8; 0],
}
#[doc = " Progress reporting callback used by methods that takes longer.\n @param text  text for user describing what is happening now\n @param stage current stage number starting with 0\n @param total count of stages. It should not change during single call of\n method.\n @param user_data is never touched by method and is used only to pass local\n data for callback\n @todo Do we want to support response for callback that allows early exit of\n execution?"]
pub type ProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        text: *const ::std::os::raw::c_char,
        stage: ::std::os::raw::c_uint,
        total: ::std::os::raw::c_uint,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Represents a single mount point and its space usage.\n The string pointers are not owned by this struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MountPoint {
    #[doc = "< The path where the filesystem is mounted."]
    pub directory: *const ::std::os::raw::c_char,
    #[doc = "< The filesystem type (e.g., \"btrfs\", \"xfs\")."]
    pub filesystem: *const ::std::os::raw::c_char,
    pub grow_only: bool,
    #[doc = "< The used space in kilobytes. This is an output field."]
    pub used_size: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MountPoint"][::std::mem::size_of::<MountPoint>() - 32usize];
    ["Alignment of MountPoint"][::std::mem::align_of::<MountPoint>() - 8usize];
    ["Offset of field: MountPoint::directory"]
        [::std::mem::offset_of!(MountPoint, directory) - 0usize];
    ["Offset of field: MountPoint::filesystem"]
        [::std::mem::offset_of!(MountPoint, filesystem) - 8usize];
    ["Offset of field: MountPoint::grow_only"]
        [::std::mem::offset_of!(MountPoint, grow_only) - 16usize];
    ["Offset of field: MountPoint::used_size"]
        [::std::mem::offset_of!(MountPoint, used_size) - 24usize];
};
pub const RESOLVABLE_KIND_RESOLVABLE_PRODUCT: RESOLVABLE_KIND = 0;
pub const RESOLVABLE_KIND_RESOLVABLE_PATCH: RESOLVABLE_KIND = 1;
pub const RESOLVABLE_KIND_RESOLVABLE_PACKAGE: RESOLVABLE_KIND = 2;
pub const RESOLVABLE_KIND_RESOLVABLE_SRCPACKAGE: RESOLVABLE_KIND = 3;
pub const RESOLVABLE_KIND_RESOLVABLE_PATTERN: RESOLVABLE_KIND = 4;
pub type RESOLVABLE_KIND = ::std::os::raw::c_uint;
#[doc = " resolvable won't be installed"]
pub const RESOLVABLE_SELECTED_NOT_SELECTED: RESOLVABLE_SELECTED = 0;
#[doc = " dependency solver select resolvable\n match TransactByValue::SOLVER"]
pub const RESOLVABLE_SELECTED_SOLVER_SELECTED: RESOLVABLE_SELECTED = 1;
#[doc = " installation proposal selects resolvable\n match TransactByValue::APPL_{LOW,HIGH} we do not need both, so we use just\n one value"]
pub const RESOLVABLE_SELECTED_APPLICATION_SELECTED: RESOLVABLE_SELECTED = 2;
#[doc = " user select resolvable for installation\n match TransactByValue::USER"]
pub const RESOLVABLE_SELECTED_USER_SELECTED: RESOLVABLE_SELECTED = 3;
#[doc = " explicitly removed by user"]
pub const RESOLVABLE_SELECTED_USER_REMOVED: RESOLVABLE_SELECTED = 4;
pub type RESOLVABLE_SELECTED = ::std::os::raw::c_uint;
#[doc = " Representation of zypp::Pattern.\n https://doc.opensuse.org/projects/libzypp/HEAD/classzypp_1_1Pattern.html"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pattern {
    #[doc = "< owned"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< owned"]
    pub category: *const ::std::os::raw::c_char,
    #[doc = "< owned"]
    pub icon: *const ::std::os::raw::c_char,
    #[doc = "< owned"]
    pub description: *const ::std::os::raw::c_char,
    #[doc = "< owned"]
    pub summary: *const ::std::os::raw::c_char,
    #[doc = "< owned"]
    pub order: *const ::std::os::raw::c_char,
    #[doc = "< owned"]
    pub repo_alias: *const ::std::os::raw::c_char,
    pub selected: RESOLVABLE_SELECTED,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Pattern"][::std::mem::size_of::<Pattern>() - 64usize];
    ["Alignment of Pattern"][::std::mem::align_of::<Pattern>() - 8usize];
    ["Offset of field: Pattern::name"][::std::mem::offset_of!(Pattern, name) - 0usize];
    ["Offset of field: Pattern::category"][::std::mem::offset_of!(Pattern, category) - 8usize];
    ["Offset of field: Pattern::icon"][::std::mem::offset_of!(Pattern, icon) - 16usize];
    ["Offset of field: Pattern::description"]
        [::std::mem::offset_of!(Pattern, description) - 24usize];
    ["Offset of field: Pattern::summary"][::std::mem::offset_of!(Pattern, summary) - 32usize];
    ["Offset of field: Pattern::order"][::std::mem::offset_of!(Pattern, order) - 40usize];
    ["Offset of field: Pattern::repo_alias"][::std::mem::offset_of!(Pattern, repo_alias) - 48usize];
    ["Offset of field: Pattern::selected"][::std::mem::offset_of!(Pattern, selected) - 56usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Patterns {
    #[doc = "< owned, *size* items"]
    pub list: *mut Pattern,
    pub size: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Patterns"][::std::mem::size_of::<Patterns>() - 16usize];
    ["Alignment of Patterns"][::std::mem::align_of::<Patterns>() - 8usize];
    ["Offset of field: Patterns::list"][::std::mem::offset_of!(Patterns, list) - 0usize];
    ["Offset of field: Patterns::size"][::std::mem::offset_of!(Patterns, size) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Repository {
    #[doc = "<"]
    pub enabled: bool,
    #[doc = "< owned"]
    pub url: *mut ::std::os::raw::c_char,
    #[doc = "< owned"]
    pub alias: *mut ::std::os::raw::c_char,
    #[doc = "< owned"]
    pub userName: *mut ::std::os::raw::c_char,
    #[doc = "< owned"]
    pub serviceName: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Repository"][::std::mem::size_of::<Repository>() - 40usize];
    ["Alignment of Repository"][::std::mem::align_of::<Repository>() - 8usize];
    ["Offset of field: Repository::enabled"][::std::mem::offset_of!(Repository, enabled) - 0usize];
    ["Offset of field: Repository::url"][::std::mem::offset_of!(Repository, url) - 8usize];
    ["Offset of field: Repository::alias"][::std::mem::offset_of!(Repository, alias) - 16usize];
    ["Offset of field: Repository::userName"]
        [::std::mem::offset_of!(Repository, userName) - 24usize];
    ["Offset of field: Repository::serviceName"]
        [::std::mem::offset_of!(Repository, serviceName) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RepositoryList {
    pub size: ::std::os::raw::c_uint,
    #[doc = "< owned, *size* items"]
    pub repos: *mut Repository,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RepositoryList"][::std::mem::size_of::<RepositoryList>() - 16usize];
    ["Alignment of RepositoryList"][::std::mem::align_of::<RepositoryList>() - 8usize];
    ["Offset of field: RepositoryList::size"]
        [::std::mem::offset_of!(RepositoryList, size) - 0usize];
    ["Offset of field: RepositoryList::repos"]
        [::std::mem::offset_of!(RepositoryList, repos) - 8usize];
};
unsafe extern "C" {
    pub fn set_zypp_progress_callback(
        progress: ZyppProgressCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
    pub fn free_status(s: *mut Status);
    #[doc = " Initialize Zypp target (where to store zypp data).\n The returned zypp context is not thread safe and should be protected by a\n mutex in the calling layer.\n @param root\n @param[out] status\n @param progress\n @param user_data\n @return zypp context"]
    pub fn init_target(
        root: *const ::std::os::raw::c_char,
        status: *mut Status,
        progress: ProgressCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut Zypp;
    #[doc = " Switch Zypp target (where to install packages to).\n @param root\n @param[out] status"]
    pub fn switch_target(zypp: *mut Zypp, root: *const ::std::os::raw::c_char, status: *mut Status);
    #[doc = " Commit zypp settings and install\n TODO: install callbacks\n @param zypp\n @param status\n @param download_callbacks\n @param security_callbacks\n @return true if there is no error"]
    pub fn commit(
        zypp: *mut Zypp,
        status: *mut Status,
        download_callbacks: *mut DownloadResolvableCallbacks,
        security_callbacks: *mut SecurityCallbacks,
        install_callbacks: *mut InstallCallbacks,
    ) -> bool;
    #[doc = " Calculates the space usage for a given list of mount points.\n This function populates the `used_size` field for each element in the\n provided `mount_points` array.\n\n @param zypp The Zypp context.\n @param[out] status Output status object.\n @param[in,out] mount_points An array of mount points to be evaluated.\n @param mount_points_size The number of elements in the `mount_points` array."]
    pub fn get_space_usage(
        zypp: *mut Zypp,
        status: *mut Status,
        mount_points: *mut MountPoint,
        mount_points_size: ::std::os::raw::c_uint,
    );
    #[doc = " Marks resolvable for installation\n @param zypp see \\ref init_target\n @param name resolvable name\n @param kind kind of resolvable\n @param who who do selection. If NOT_SELECTED is used, it will be empty\n operation.\n @param[out] status (will overwrite existing contents)"]
    pub fn resolvable_select(
        zypp: *mut Zypp,
        name: *const ::std::os::raw::c_char,
        kind: RESOLVABLE_KIND,
        who: RESOLVABLE_SELECTED,
        status: *mut Status,
    );
    #[doc = " Unselect resolvable for installation. It can still be installed as\n dependency.\n @param zypp see \\ref init_target\n @param name resolvable name\n @param kind kind of resolvable\n @param who who do unselection. Only unselect if it is higher or equal level\n then who do the selection.\n @param[out] status (will overwrite existing contents)"]
    pub fn resolvable_unselect(
        zypp: *mut Zypp,
        name: *const ::std::os::raw::c_char,
        kind: RESOLVABLE_KIND,
        who: RESOLVABLE_SELECTED,
        status: *mut Status,
    );
    #[doc = " Reset status of all resolvables, unselects selected packages, patterns...\n Note: this also resets the user locks (\"taboo\" or \"keep installed\")"]
    pub fn resolvable_reset_all(_zypp: *mut Zypp);
    #[doc = " @brief Amount of packages selected for installation\n @param _zypp see \\ref init_target\n @return count of packages"]
    pub fn packages_to_install(_zypp: *mut Zypp) -> ::std::os::raw::c_uint;
    #[doc = " Get Pattern details.\n Unknown patterns are simply omitted from the result. Match by\n PatternInfo.name, not by index."]
    pub fn get_patterns(_zypp: *mut Zypp, status: *mut Status) -> Patterns;
    pub fn free_patterns(patterns: *const Patterns);
    pub fn import_gpg_key(
        zypp: *mut Zypp,
        pathname: *const ::std::os::raw::c_char,
        status: *mut Status,
    );
    #[doc = " check if url has local schema\n @param url url to check\n @param[out] status (will overwrite existing contents)\n @return true if url is local, for invalid url status is set to error"]
    pub fn is_local_url(url: *const ::std::os::raw::c_char, status: *mut Status) -> bool;
    #[doc = " check if package is available\n @param zypp see \\ref init_target\n @param tag package name, provides or file path\n @param[out] status (will overwrite existing contents)\n @return true if package is available. In case of error it fills status and\n return value is undefined"]
    pub fn is_package_available(
        zypp: *mut Zypp,
        tag: *const ::std::os::raw::c_char,
        status: *mut Status,
    ) -> bool;
    #[doc = " check if package is selected for installation\n @param zypp see \\ref init_target\n @param tag package name, provides or file path\n @param[out] status (will overwrite existing contents)\n @return true if package is selected. In case of error it fills status and\n return value is undefined"]
    pub fn is_package_selected(
        zypp: *mut Zypp,
        tag: *const ::std::os::raw::c_char,
        status: *mut Status,
    ) -> bool;
    #[doc = " Runs solver\n @param zypp see \\ref init_target\n @param only_required if true, only required packages are installed (ignoring\n recommended packages)\n @param[out] status (will overwrite existing contents)\n @return true if solver pass and false if it found some dependency issues"]
    pub fn run_solver(zypp: *mut Zypp, only_required: bool, status: *mut Status) -> bool;
    #[doc = " the last call that will free all pointers to zypp holded by agama"]
    pub fn free_zypp(zypp: *mut Zypp);
    #[doc = " repository array in list.\n when no longer needed, use \\ref free_repository_list to release memory\n @param zypp see \\ref init_target\n @param[out] status (will overwrite existing contents)"]
    pub fn list_repositories(zypp: *mut Zypp, status: *mut Status) -> RepositoryList;
    pub fn free_repository_list(repo_list: *mut RepositoryList);
    #[doc = " Adds repository to repo manager\n @param zypp see \\ref init_target\n @param alias have to be unique\n @param url can contain repo variables\n @param[out] status (will overwrite existing contents)\n @param callback pointer to function with callback or NULL\n @param user_data"]
    pub fn add_repository(
        zypp: *mut Zypp,
        alias: *const ::std::os::raw::c_char,
        url: *const ::std::os::raw::c_char,
        status: *mut Status,
        callback: ZyppProgressCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
    #[doc = " Disable repository in repo manager\n @param zypp see \\ref init_target\n @param alias identifier of repository"]
    pub fn disable_repository(
        zypp: *mut Zypp,
        alias: *const ::std::os::raw::c_char,
        status: *mut Status,
    );
    #[doc = " Changes url of given repository\n @param zypp see \\ref init_target\n @param alias identifier of repository\n @param alias have to be unique"]
    pub fn set_repository_url(
        zypp: *mut Zypp,
        alias: *const ::std::os::raw::c_char,
        url: *const ::std::os::raw::c_char,
        status: *mut Status,
    );
    #[doc = " Removes repository from repo manager\n @param zypp see \\ref init_target\n @param alias have to be unique\n @param[out] status (will overwrite existing contents)\n @param callback pointer to function with callback or NULL\n @param user_data"]
    pub fn remove_repository(
        zypp: *mut Zypp,
        alias: *const ::std::os::raw::c_char,
        status: *mut Status,
        callback: ZyppProgressCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
    #[doc = " Adds service to repo manager\n @param zypp see \\ref init_target\n @param alias have to be unique\n @param url\n @param[out] status (will overwrite existing contents)"]
    pub fn add_service(
        zypp: *mut Zypp,
        alias: *const ::std::os::raw::c_char,
        url: *const ::std::os::raw::c_char,
        status: *mut Status,
    );
    #[doc = "\n @param zypp see \\ref init_target\n @param alias alias of repository to refresh\n @param[out] status (will overwrite existing contents)\n @param progress pointer to struct with callbacks or NULL if no progress is\n needed\n @param security pointer to struct with security callbacks"]
    pub fn refresh_repository(
        zypp: *mut Zypp,
        alias: *const ::std::os::raw::c_char,
        status: *mut Status,
        progress: *mut DownloadProgressCallbacks,
        security: *mut SecurityCallbacks,
    );
    #[doc = "\n @param zypp see \\ref init_target\n @param alias alias of service to refresh\n @param[out] status (will overwrite existing contents)"]
    pub fn refresh_service(
        zypp: *mut Zypp,
        alias: *const ::std::os::raw::c_char,
        status: *mut Status,
    );
    pub fn build_repository_cache(
        zypp: *mut Zypp,
        alias: *const ::std::os::raw::c_char,
        status: *mut Status,
        callback: ZyppProgressCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
    pub fn load_repository_cache(
        zypp: *mut Zypp,
        alias: *const ::std::os::raw::c_char,
        status: *mut Status,
    );
}
