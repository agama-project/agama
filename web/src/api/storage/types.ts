/*
 * Copyright (c) [2024] SUSE LLC
 *
 * All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as published
 * by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, contact SUSE LLC.
 *
 * To contact SUSE LLC about this file by physical or electronic mail, you may
 * find current contact information at www.suse.com.
 */

// This file is auto-generated by @hey-api/openapi-ts

/**
 * Represents a single change action done to storage
 */
export type Action = {
  delete: boolean;
  device: DeviceSid;
  resize: boolean;
  subvol: boolean;
  text: string;
};

export type BlockDevice = {
  active: boolean;
  encrypted: boolean;
  shrinking: ShrinkingInfo;
  size: DeviceSize;
  start: number;
  systems: Array<string>;
  udevIds: Array<string>;
  udevPaths: Array<string>;
};

export type Component = {
  deviceNames: Array<string>;
  devices: Array<DeviceSid>;
  type: string;
};

/**
 * Information about system device created by composition to reflect different devices on system
 */
export type Device = {
  blockDevice?: BlockDevice | null;
  component?: Component | null;
  deviceInfo: DeviceInfo;
  drive?: Drive | null;
  filesystem?: Filesystem | null;
  lvmLv?: LvmLv | null;
  lvmVg?: LvmVg | null;
  md?: Md | null;
  multipath?: Multipath | null;
  partition?: Partition | null;
  partitionTable?: PartitionTable | null;
  raid?: Raid | null;
};

export type DeviceInfo = {
  description: string;
  name: string;
  sid: DeviceSid;
};

export type DeviceSid = number;

export type DeviceSize = number;

export type DiscoverParams = {
  /**
   * iSCSI server address.
   */
  address: string;
  options?: ISCSIAuth;
  /**
   * iSCSI service port.
   */
  port: number;
};

export type Drive = {
  bus: string;
  busId: string;
  driver: Array<string>;
  info: DriveInfo;
  model: string;
  transport: string;
  type: string;
  vendor: string;
};

export type DriveInfo = {
  dellBOSS: boolean;
  sdCard: boolean;
};

export type Filesystem = {
  label: string;
  mountPath: string;
  sid: DeviceSid;
  type: string;
};

export type ISCSIAuth = {
  /**
   * Password for authentication by target.
   */
  password?: string | null;
  /**
   * Password for authentication by initiator.
   */
  reverse_password?: string | null;
  /**
   * Username for authentication by initiator.
   */
  reverse_username?: string | null;
  /**
   * Username for authentication by target.
   */
  username?: string | null;
};

export type ISCSIInitiator = {
  ibft: boolean;
  name: string;
};

/**
 * ISCSI node
 */
export type ISCSINode = {
  /**
   * Target IP address (in string-like form).
   */
  address: string;
  /**
   * Whether the node is connected (there is a session).
   */
  connected: boolean;
  /**
   * Whether the node was initiated by iBFT
   */
  ibft: boolean;
  /**
   * Artificial ID to match it against the D-Bus backend.
   */
  id: number;
  /**
   * Interface name.
   */
  interface: string;
  /**
   * Target port.
   */
  port: number;
  /**
   * Startup status (TODO: document better)
   */
  startup: string;
  /**
   * Target name.
   */
  target: string;
};

export type InitiatorParams = {
  /**
   * iSCSI initiator name.
   */
  name: string;
};

export type LoginParams = ISCSIAuth & {
  /**
   * Startup value.
   */
  startup: string;
};

export type LoginResult = "Success" | "InvalidStartup" | "Failed";

export type LvmLv = {
  volumeGroup: DeviceSid;
};

export type LvmVg = {
  logicalVolumes: Array<DeviceSid>;
  physicalVolumes: Array<DeviceSid>;
  size: DeviceSize;
};

export type Md = {
  devices: Array<DeviceSid>;
  level: string;
  uuid: string;
};

export type Multipath = {
  wires: Array<string>;
};

export type NodeParams = {
  /**
   * Startup value.
   */
  startup: string;
};

export type Partition = {
  device: DeviceSid;
  efi: boolean;
};

export type PartitionTable = {
  partitions: Array<DeviceSid>;
  type: string;
  unusedSlots: Array<UnusedSlot>;
};

export type PingResponse = {
  /**
   * API status
   */
  status: string;
};

export type ProductParams = {
  /**
   * Encryption methods allowed by the product.
   */
  encryptionMethods: Array<string>;
  /**
   * Mount points defined by the product.
   */
  mountPoints: Array<string>;
};

/**
 * Represents a proposal configuration
 */
export type ProposalSettings = {
  bootDevice: string;
  configureBoot: boolean;
  defaultBootDevice: string;
  encryptionMethod: string;
  encryptionPBKDFunction: string;
  encryptionPassword: string;
  spaceActions: Array<SpaceActionSettings>;
  spacePolicy: string;
  target: ProposalTarget;
  targetDevice?: string | null;
  targetPVDevices?: Array<string> | null;
  volumes: Array<Volume>;
};

/**
 * Represents a proposal patch -> change of proposal configuration that can be partial
 */
export type ProposalSettingsPatch = {
  bootDevice?: string | null;
  configureBoot?: boolean | null;
  encryptionMethod?: string | null;
  encryptionPBKDFunction?: string | null;
  encryptionPassword?: string | null;
  spaceActions?: Array<SpaceActionSettings> | null;
  spacePolicy?: string | null;
  target?: ProposalTarget | null;
  targetDevice?: string | null;
  targetPVDevices?: Array<string> | null;
  volumes?: Array<Volume> | null;
};

export type ProposalTarget = "disk" | "newLvmVg" | "reusedLvmVg";

export type Raid = {
  devices: Array<string>;
};

export type ShrinkingInfo =
  | {
      supported: DeviceSize;
    }
  | {
      unsupported: Array<string>;
    };

export type SpaceAction = "force_delete" | "resize" | "keep";

export type SpaceActionSettings = {
  action: SpaceAction;
  device: string;
};

export type UnusedSlot = {
  size: DeviceSize;
  start: number;
};

/**
 * Represents a single volume
 */
export type Volume = {
  autoSize: boolean;
  fsType: string;
  maxSize?: DeviceSize | null;
  minSize?: DeviceSize | null;
  mountOptions: Array<string>;
  mountPath: string;
  outline?: VolumeOutline | null;
  snapshots: boolean;
  target: VolumeTarget;
  targetDevice?: string | null;
  transactional?: boolean | null;
};

/**
 * Represents volume outline aka requirements for volume
 */
export type VolumeOutline = {
  adjustByRam: boolean;
  fsTypes: Array<string>;
  /**
   * whether it is required
   */
  required: boolean;
  sizeRelevantVolumes: Array<string>;
  snapshotsAffectSizes: boolean;
  snapshotsConfigurable: boolean;
  supportAutoSize: boolean;
};

/**
 * Represents value for target key of Volume
 * It is snake cased when serializing to be compatible with yast2-storage-ng.
 */
export type VolumeTarget = "default" | "new_partition" | "new_vg" | "device" | "filesystem";

export type DevicesDirtyResponse = boolean;

export type StagingDevicesResponse = Array<Device>;

export type SystemDevicesResponse = Array<Device>;

export type DiscoverData = {
  requestBody: DiscoverParams;
};

export type DiscoverResponse = void;

export type InitiatorResponse = ISCSIInitiator;

export type UpdateInitiatorData = {
  requestBody: InitiatorParams;
};

export type UpdateInitiatorResponse = void;

export type NodesResponse = Array<ISCSINode>;

export type UpdateNodeData = {
  /**
   * iSCSI artificial ID.
   */
  id: number;
  requestBody: NodeParams;
};

export type UpdateNodeResponse = NodeParams;

export type DeleteNodeData = {
  /**
   * iSCSI artificial ID.
   */
  id: number;
};

export type DeleteNodeResponse = void;

export type LoginNodeData = {
  /**
   * iSCSI artificial ID.
   */
  id: number;
  requestBody: LoginParams;
};

export type LoginNodeResponse = void;

export type LogoutNodeData = {
  /**
   * iSCSI artificial ID.
   */
  id: number;
};

export type LogoutNodeResponse = void;

export type StorageProbeResponse = unknown;

export type ProductParamsResponse = ProductParams;

export type VolumeForData = {
  /**
   * Mount path of the volume (empty for an arbitrary volume).
   */
  mountPath: string;
};

export type VolumeForResponse = Volume;

export type ActionsResponse = Array<Action>;

export type GetProposalSettingsResponse = ProposalSettings;

export type SetProposalSettingsData = {
  /**
   * Proposal settings
   */
  requestBody: ProposalSettingsPatch;
};

export type SetProposalSettingsResponse = boolean;

export type UsableDevicesResponse = Array<DeviceSid>;

export type PingResponse2 = PingResponse;
