#! /usr/bin/node

/*
This script generates the POT file with product translations from product
YAML files.

Requirements: NodeJS, run "npm ci" to install the needed NPM packages

Usage:

  products_pot *.yaml
*/

const fs = require("fs");
const process = require("process");

const { LineCounter, parseDocument } = require("yaml");
const gettextParser = require("gettext-parser");

/**
 * Translatable text with source location
 */
class POEntry {
  text;
  file;
  line;
  translators_comment;

  /**
   * Constructor
   * @param {string} text - text of the description
   * @param {string} file - file name
   * @param {number} line - line location
   * @param {string} translators_comment - translators comment
   */
  constructor(text, file, line, translators_comment) {
    this.text = text;
    this.file = file;
    this.line = line;
    this.translators_comment = translators_comment;
  }
}

// collects translatable texts (POEntries) and generates the final POT file
class POFile {
  entries = [];

  /**
   * generate a time stamp string for the POT file header
   * @returns {string} timestamp
   */
  #timestamp() {
    const date = new Date();
    return (
      date.getUTCFullYear() +
      "-" +
      this.#padNumber(date.getUTCMonth() + 1) +
      "-" +
      this.#padNumber(date.getUTCDate()) +
      " " +
      this.#padNumber(date.getUTCHours()) +
      ":" +
      this.#padNumber(date.getUTCMinutes()) +
      "+0000"
    );
  }

  /**
   * generate the POT file content
   * @returns {string} generated POT file or empty string if there are no entries
   */
  dump() {
    if (this.entries.length === 0) return "";

    // template file with the default POT file header
    const template = require("./template.json");
    template.headers["POT-Creation-Date"] = this.#timestamp();

    const translations = template.translations[""];

    this.entries.forEach((e) => {
      const ref = e.file + ":" + e.line;
      if (translations[e.text]) {
        // the same text was already found at a different place, just merge the
        // locations and translators comments if not already there
        const item = translations[e.text];
        if (!item.comments.translator.split("\n").includes(e.translators_comment)) {
          item.comments.translator += "\n" + e.translators_comment;
        }
        if (!item.comments.reference.split("\n").includes(ref)) {
          item.comments.reference += "\n" + ref;
        }
      } else {
        translations[e.text] = {
          msgid: e.text,
          comments: {
            translator: e.translators_comment,
            reference: ref,
          },
          msgstr: [""],
        };
      }
    });

    // sort the output by the msgid to have consistent results
    return String(gettextParser.po.compile(template, { sort: true }));
  }

  /**
   * Formats the number as a string with at least 2 digits, adds leading zero if needed
   * @param n number
   * @returns formatted number
   */
  #padNumber(n) {
    return n.toString().padStart(2, "0");
  }
}

/**
 * Reads and parses the YAML product file
 */
class YamlReader {
  file;

  /**
   * Constructor
   * @param {string} file - name of the YAML file to read
   */
  constructor(file) {
    this.file = file;
  }

  /**
   * Read and parse the YAML file
   * @returns {POEntry[]} the found translatable entries
   */
  read() {
    const data = fs.readFileSync(this.file, "utf-8");
    const entries = [];

    const lineCounter = new LineCounter();
    const parsed = parseDocument(data, { lineCounter });

    const product = parsed.get("name");
    const descriptionNode = parsed.get("description", true);

    if (descriptionNode) {
      const line = lineCounter.linePos(descriptionNode.range[0]).line;
      entries.push(
        new POEntry(
          parsed.get("description"),
          this.file,
          line,
          `TRANSLATORS: description of product "${product}"`
        )
      );
    }

    const modes = parsed.get("modes", true);
    if (modes && modes.items) {
      modes.items.forEach((mode) => {
        if (!mode.get) return;

        const modeName = mode.get("name");
        const nameNode = mode.get("name", true);
        if (nameNode) {
          const line = lineCounter.linePos(nameNode.range[0]).line;
          entries.push(
            new POEntry(
              modeName,
              this.file,
              line,
              `TRANSLATORS: name of the installation mode for product "${product}"`
            )
          );
        }

        const descriptionNode = mode.get("description", true);
        if (descriptionNode) {
          const line = lineCounter.linePos(descriptionNode.range[0]).line;
          entries.push(
            new POEntry(
              mode.get("description"),
              this.file,
              line,
              `TRANSLATORS: description of installation mode "${modeName}" for product "${product}"`
            )
          );
        }
      });
    }

    return entries;
  }
}

const output = new POFile();
// script arguments (the first arg is executor path ("/usr/bin/node"),
// the second is name of this script)
const [, , ...params] = process.argv;

params.forEach((f) => {
  const reader = new YamlReader(f);
  const entries = reader.read();
  output.entries.push(...entries);
});

console.log(output.dump());
